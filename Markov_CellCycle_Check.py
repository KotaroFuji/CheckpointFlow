#simulate cell states

#------Assumptions regarding cell state transitions------
#cells cycle when there is no damage: G1 -> S -> G2 -> M -> G1
#cells can exit the cell cycle when damaged during G1 or G2: G1 -> G0, G2 -> G0
#cells can reenter the cell cycle: G0 -> S
#damage can prevent cell cycle reentry 
 
#------Assumptions regarding mitotic error------
#DNA damage increases chances of mitotic error upon division (reflected by DNA damage-derived micronuclei in real cells)
#the division of a polyploid cell, regardless of DNA damage, also increases the chances of mitotic error (reflected by nuclear deformation and chromosome missegregation-derived micronuclei in real cells)
#we define diploid daughter cells generated by erroneous mitosis as type 1 cells
#we define polyploid daughter cells generated by erroneous mitosis as type 2 cells
  
#------Other assumptions and notes------
#This model takes into account an increase in cell number following divisions; when a cell exits M phase, it generates two daughter cells.
#1 unit of time: 10min 
#DNA damage will be caused at time point 144 (1440min, 24h)
#cells repair their DNA. Based on gH2AX data, this model assumes that cells decrease their DSB level 0.9982279 fold per 1 unit of time 

import math
import numpy as np
import random
from pyprobs import Probability as pr
from decimal import Decimal as deci
from itertools import combinations
import multiprocessing as mp
import sys

#-----------specify parameters-----------

num_cells = 500 		#the number of cells to simulate per parameter condition

G1_mean = 56			#mean G1 duration
S_mean = 20				#mean S duration
G2_mean = 22			#mean G2 duration
M_mean = 3				#mean M duration

mean_cellcycle = G1_mean + S_mean + G2_mean + M_mean

G1_sd = 13				#G1 standard deviation
S_sd = 9				#S standard deviation
G2_sd = 6				#G2 standard deviation
M_sd = 1				#M standard deviation 

repair_rate = 0.9982279 #the fold reduction in DSB level per 1 unit of time (10min) 

k_G0toS = 1 - math.pow(0.4,1/176) #the maximum probability a G0 cell reenters S phase per minute,

Kd_MN = 1 			#the Kd value for mitotic error in response to damage

P_MN_error = 0.5       #The probability of a polyploid division resulting in mitotic error, independent of DNA damage level.

maximum_minutes = 144 + 864 	#specify simulation minutes, here it is pre-damage condition in 24h (1440min) and post-damage condition in 6d (8640min)
								
perturb_start = 142						#the time point at which the checkpoint(s) is perturbed.
perturb_end = maximum_minutes + 100 	#the time point to end checkpoint perturbation

start_write = maximum_minutes - 1 #specify from which time point the simulation results should be written into the output files. If only the results from the last time point are needed, both start_write and end_write should be maximum_minutes - 1. If the simulation results from the whole time points are needed, then specify so that start_write = 0 and end_write = maximum_minutes - 1.
end_write = maximum_minutes - 1  	
#----------------------------------------------





#---------------RUN SIMULATION-----------------

#----------------------------------------------


inname = sys.argv[1] 					#the input file that specifies important parameters. This will be one of the output files from the Make_Parameter_Sets_Parameterscan_Final.py
outname = "MarkovModel_simulation_results_"+ sys.argv[1].strip(".txt").split("/")[-1]+".txt" 
#------------acquire necessary parameters-----------
parset = 0
parameterset = {}

filein = open(inname,"r")
nrow = 0
for line in filein:
	x = line.strip().split("\t")
	nrow += 1
	if nrow == 1:
		for num in range(0,len(x)):
			if x[num] == "DSBcondition":
				DSBcondition_colnum = num
			elif x[num] == "Kd_G1toG0":
				Kd_G1toG0_colnum = num
			elif x[num] == "Kd_G2toG0":
				Kd_G2toG0_colnum = num
			elif x[num] == "Kd_G0toS":
				Kd_G0toS_colnum = num
			elif x[num] == "G1check_inhibition":
				G1check_inhibition_colnum = num
			elif x[num] == "G2check_inhibition":
				G2check_inhibition_colnum = num
			elif x[num] == "check_inhibition":
				check_inhibition_colnum = num
			elif x[num] == "t_G1toG0":
				t_G1toG0_colnum = num
			elif x[num] == "t_G2toG0":
				t_G2toG0_colnum = num
			else:
				pass
	else:
		DSBcondition = float(x[DSBcondition_colnum])
		Kd_G1toG0 = float(x[Kd_G1toG0_colnum])
		Kd_G2toG0 = float(x[Kd_G2toG0_colnum])
		Kd_G0toS = float(x[Kd_G0toS_colnum])
		G1check_inhibition = float(x[G1check_inhibition_colnum])
		G2check_inhibition = float(x[G2check_inhibition_colnum])
		check_inhibition = float(x[check_inhibition_colnum])
		t_G1toG0 = int(x[t_G1toG0_colnum])
		t_G2toG0 = int(x[t_G2toG0_colnum])
		
		parset+= 1

		parameterset[parset] = [DSBcondition,Kd_G1toG0,Kd_G2toG0,Kd_G0toS,G1check_inhibition,G2check_inhibition,check_inhibition,t_G1toG0,t_G2toG0]



phase_code = {0:"G0",1:"S",2:"G2",3:"M",4:"G1"}

#---phase_DNAcontent_ploidy---

G1_DNAcontent_ploidy = {}
S_DNAcontent_ploidy = {}
G2M_DNAcontent_ploidy = {}

for num in range(0,50):
	#---for G1
	DNAcontent = 2*2**num
	ploidy = DNAcontent
	G1_DNAcontent_ploidy[DNAcontent] = ploidy
	
	#---for S
	DNAcontent = 3*2**num
	ploidy = int(DNAcontent*2/3)
	S_DNAcontent_ploidy[DNAcontent] = ploidy
	
	#---for G2 and M
	DNAcontent = 4*2**num
	ploidy = int(DNAcontent*1/2)
	G2M_DNAcontent_ploidy[DNAcontent] = ploidy


#calculate G1 PDF
G1duration_sample = [int(i) for i in list(G1_mean + G1_sd*np.random.randn(10000))] 
G1PDF = {}
for min in range(1,maximum_minutes+1):
	frequency = G1duration_sample.count(min)/float(len(G1duration_sample))
	G1PDF[min] = frequency

G1PDF[G1_mean+(4*G1_sd)] = 1	#the cell has to exit G1 when it spends more time than G1_mean+(3*G1_sd) minutes

#calculate S PDF
Sduration_sample = [int(i) for i in list(S_mean + S_sd*np.random.randn(10000))]
SPDF = {}
for min in range(1,maximum_minutes+1):
	frequency = Sduration_sample.count(min)/float(len(Sduration_sample))
	SPDF[min] = frequency

SPDF[S_mean+(4*S_sd)] = 1

#calculate G2 PDF
G2duration_sample = [int(i) for i in list(G2_mean + G2_sd*np.random.randn(10000))]
G2PDF = {}
for min in range(1,maximum_minutes+1):
	frequency = G2duration_sample.count(min)/float(len(G2duration_sample))
	G2PDF[min] = frequency

G2PDF[G2_mean+(4*G2_sd)] = 1

#calculate M PDF
Mduration_sample = [int(i) for i in list(M_mean + M_sd*np.random.randn(10000))]
MPDF = {}
for min in range(1,maximum_minutes+1):
	frequency = Mduration_sample.count(min)/float(len(Mduration_sample))
	MPDF[min] = frequency
	
MPDF[M_mean+(4*M_sd)] = 1

#----make a function for a cell fate decision ----
def decision(phase,Tphase,DSB,MN):

	P_G1toG0 = k_G1toG0 * ((DSB**3) / (DSB**3 + Kd_G1toG0))       	#Assuming switch like mechanism, n = 3
	P_G2toG0 = k_G2toG0 * ((DSB**3) / (DSB**3 + Kd_G2toG0)) 		#Assuming switch like mechanism, n = 3  
	P_G0toS = k_G0toS * ((Kd_G0toS) / (DSB + Kd_G0toS)) 			#G0 maintenance is leaky, n = 1

	if phase == 1:  #phase is S phase
		if pr.prob(SPDF[Tphase]) == True:
			return 1
		else:
			return 0
	elif phase == 2:	#phase is G2 phase
		if True if random.random() > 1-P_G2toG0 else False:
			return -1
		else:
			if pr.prob(G2PDF[Tphase]) == True:
				return 1
			else:
				return 0
	elif phase == 3:	#phase is M phase
		if pr.prob(MPDF[Tphase]) == True:
			return 1
		else:
			return 0
	elif phase == 4:	#phase is G1 phase
		if True if random.random() > 1-P_G1toG0 else False:
			return -1
		else:
			if pr.prob(G1PDF[Tphase]) == True:
				return 1
			else:
				return 0
	elif phase == 0: 	#phase is G0 phase
		if True if random.random() > 1-P_G0toS else False:  
			return 1
		else:
			return 0
	else:
		print("error")
		
#the action of a cell is either to proceed (move to the next cellular state), to stay (keep the current state), or to retreat (move to G0)
#proceed = 1, stay = 0, retreat = -1

#generate random positions along the cell cycle
random_positions = [random.randrange(1,mean_cellcycle+1) for i in range(0,num_cells)]

#generate a seeding asynchronous population of diploid cells
#Kd values need to be set just for the initial seeding. These Kd values will be overwritten by the specified Kds in the input file once the actual simulation starts
Kd_G1toG0 = 0.5
Kd_G2toG0 = 2
Kd_G0toS = 0.2
k_G1toG0 = 1 - math.pow(0.01,1/24) 
k_G2toG0 = 1 - math.pow(0.01,1/1)

cellID_PhaseDNAcontentPloidyTphaseActionMN = {}
for cell in range(0,num_cells):
	posi = random_positions[cell]
	cellID = str(cell+1)
	DSB = 0
	MN = 0  
	
	if posi <= G1_mean:
		phase = 4	#the cell is in G1 phase
		DNAcontent = 2
		ploidy = G1_DNAcontent_ploidy[DNAcontent]
		Tphase = posi
				
	elif posi <= G1_mean + S_mean:
		phase = 1   #the cell is in S phase
		DNAcontent = 3	#for convenience, in reality, it will be somewhere between 2C and 4C
		ploidy = S_DNAcontent_ploidy[DNAcontent]
		Tphase = posi - G1_mean
	
	elif posi <= G1_mean + S_mean + G2_mean:
		phase = 2  	#the cell is in G2 phase
		DNAcontent = 4	
		ploidy = G2M_DNAcontent_ploidy[DNAcontent]
		Tphase = posi - G1_mean - S_mean
	
	else:  #the cell is in M phase
		phase = 3  	#the cell is in M phase
		DNAcontent = 4	
		ploidy = G2M_DNAcontent_ploidy[DNAcontent]
		Tphase = posi - G1_mean - S_mean - G2_mean
	
	action = decision(phase,Tphase,DSB,MN) 
	
	cellID_PhaseDNAcontentPloidyTphaseActionMN[cellID] = [phase,DNAcontent,ploidy,Tphase,action,MN]

	
fileout = open(outname,"w")
fileout.write("parset\treplicate\tcellID\ttime\tDSB\tphase\tDNAcontent\tploidy\tMN\tDSBcondition\tk_G1toG0condition\tk_G2toG0condition\tk_G0toScondition\tKd_G1toG0condition\tKd_G2toG0condition\tKd_G0toScondition\tG1checkpoint_inhibition\tG2check_inhibition\tcheck_inhibition\n")
fileout.flush()
fileout.close()

fileout = open(outname,"a")


countparset = 0
for parset in parameterset:

	countparset  += 1
	print(countparset)

	parametersetlist = parameterset[parset]
	DSBcondition = parametersetlist[0]
	Kd_G1toG0background = parametersetlist[1]
	Kd_G2toG0background = parametersetlist[2]
	Kd_G0toSbackground = parametersetlist[3]
	G1check_inhibition_perturbed = parametersetlist[4]
	G2check_inhibition_perturbed = parametersetlist[5]
	check_inhibition_perturbed = parametersetlist[6]
	t_G1toG0 = parametersetlist[7]
	t_G2toG0 = parametersetlist[8]
	
	k_G1toG0 = 1 - math.pow(0.01,1/t_G1toG0) 
	k_G2toG0 = 1 - math.pow(0.01,1/t_G2toG0)
	
	for rep in [1,2,3]:
	
		#---putting the seeding cells into the pool_list---
		pool_list = {1:{}}
		cellID_poolnum = {}
		for cellID in cellID_PhaseDNAcontentPloidyTphaseActionMN:
		
			cellID_poolnum[cellID] = 1  #assigning pool number to the seeding cells
			
			initial_time = 0
			phase = cellID_PhaseDNAcontentPloidyTphaseActionMN[cellID][0]
			DNAcontent = cellID_PhaseDNAcontentPloidyTphaseActionMN[cellID][1]
			ploidy = cellID_PhaseDNAcontentPloidyTphaseActionMN[cellID][2]
			Tphase = cellID_PhaseDNAcontentPloidyTphaseActionMN[cellID][3]
			action = cellID_PhaseDNAcontentPloidyTphaseActionMN[cellID][4]
			MN = cellID_PhaseDNAcontentPloidyTphaseActionMN[cellID][5]
			
			pool_list[1][cellID] = {"initial_time":0,"DNAcontent":DNAcontent,"ploidy":ploidy,"Tphase":Tphase,"action":action,"MN":MN,"phase":phase}
		
		for poolnum in range(1,10): #assuming that the number of pools doesn't exceed 10
			if poolnum in pool_list:
				cellID_list = list(pool_list[poolnum].keys())
				
				for cellID in cellID_list:
				
					num_division = 0		#track number of division
	
					current_poolnum = cellID_poolnum[cellID]
					next_poolnum = current_poolnum+1
	
					initial_time = pool_list[current_poolnum][cellID]["initial_time"]    				#the initial state of the cell
					DNAcontent = pool_list[current_poolnum][cellID]["DNAcontent"]
					phase = pool_list[current_poolnum][cellID]["phase"]
					ploidy = pool_list[current_poolnum][cellID]["ploidy"]
					Tphase = pool_list[current_poolnum][cellID]["Tphase"]
					action = pool_list[current_poolnum][cellID]["action"]
					MN = pool_list[current_poolnum][cellID]["MN"]
	
					if initial_time < 144:	#time 144 is when you apply DNA damage, so before, it's zero
						DSB = 0
					else:
						elapsed_from_damage = initial_time - 144
						DSB = DSBcondition*(repair_rate)**elapsed_from_damage
	
					#---set information for time 0
					cellID_time_DSBPhaseTphaseDNAcontentActionPloidyMNparameters = {}
	
					cellID_time_DSBPhaseTphaseDNAcontentActionPloidyMNparameters[cellID] = {initial_time:[DSB,phase,Tphase,DNAcontent,action,ploidy,MN,DSBcondition,k_G1toG0,k_G2toG0,k_G0toS,Kd_G1toG0background,Kd_G2toG0background,Kd_G0toSbackground]}
	 	
					#-----------start the simulation--------------
					for time in range(initial_time+1,maximum_minutes+1):
	 		
	 					#-----DSB level---
						if time < 144:	#time 144 is when you apply DNA damage, so before, it's zero
							DSB = 0
						else:
							elapsed_from_damage = time - 144
							DSB = DSBcondition*(repair_rate)**elapsed_from_damage
	 					#DSBs are repaired in the rate that was observed from the experiment

	 					#----setting perturbed parameters (the ones that change during the simulation time)-----
	 			
						if time >= perturb_start and time <= perturb_end:  #when to perturb 
							G2check_inhibition = G2check_inhibition_perturbed 
							G1check_inhibition = G1check_inhibition_perturbed
							check_inhibition = check_inhibition_perturbed
						else:
							G2check_inhibition = 1 #1 is no inhibition from the background condition, number greater than 1 is more inhibition
							G1check_inhibition = 1
							check_inhibition = 1
	
						Kd_G1toG0 = Kd_G1toG0background*G1check_inhibition*check_inhibition
						Kd_G2toG0 = Kd_G2toG0background*G2check_inhibition*check_inhibition
						Kd_G0toS = Kd_G0toSbackground*G1check_inhibition*check_inhibition																		
	 		
						if cellID_time_DSBPhaseTphaseDNAcontentActionPloidyMNparameters[cellID][time-1][4] == -1: #the decision in the previous time frame was to recede to G0
	 						phase = 0  #which means the current phase will revert to G0 (phase = 0)
	 						Tphase = 1
	 						DNAcontent = cellID_time_DSBPhaseTphaseDNAcontentActionPloidyMNparameters[cellID][time-1][3] #the DNA content will not change by receding to G0
	 						ploidy = cellID_time_DSBPhaseTphaseDNAcontentActionPloidyMNparameters[cellID][time-1][5]
	 						MN = cellID_time_DSBPhaseTphaseDNAcontentActionPloidyMNparameters[cellID][time-1][6]
	 		
						elif cellID_time_DSBPhaseTphaseDNAcontentActionPloidyMNparameters[cellID][time-1][4] == 0: #the decision was to stay at the previous phase
	 						phase = cellID_time_DSBPhaseTphaseDNAcontentActionPloidyMNparameters[cellID][time-1][1]
	 						Tphase = cellID_time_DSBPhaseTphaseDNAcontentActionPloidyMNparameters[cellID][time-1][2] + 1
	 						DNAcontent = cellID_time_DSBPhaseTphaseDNAcontentActionPloidyMNparameters[cellID][time-1][3]
	 						ploidy = cellID_time_DSBPhaseTphaseDNAcontentActionPloidyMNparameters[cellID][time-1][5]
	 						MN = cellID_time_DSBPhaseTphaseDNAcontentActionPloidyMNparameters[cellID][time-1][6]
	 		
						elif cellID_time_DSBPhaseTphaseDNAcontentActionPloidyMNparameters[cellID][time-1][4] == 1: #the decision was to proceed to the next phase
							Tphase = 1
	 			
							if cellID_time_DSBPhaseTphaseDNAcontentActionPloidyMNparameters[cellID][time-1][1] == 4: #if the previous frame was G1
								phase = 1 #then the current phase is S phase
								DNAcontent = int(1.5*cellID_time_DSBPhaseTphaseDNAcontentActionPloidyMNparameters[cellID][time-1][3]) #for convenience, e.g., G1 = 2C and S = 3C (in reality it's 2C to 4C), so the content grows 1.5 times the G1
								ploidy = cellID_time_DSBPhaseTphaseDNAcontentActionPloidyMNparameters[cellID][time-1][5]
								MN = cellID_time_DSBPhaseTphaseDNAcontentActionPloidyMNparameters[cellID][time-1][6]
	 				
							elif cellID_time_DSBPhaseTphaseDNAcontentActionPloidyMNparameters[cellID][time-1][1] == 1: #if the previous frame was S
								phase = (cellID_time_DSBPhaseTphaseDNAcontentActionPloidyMNparameters[cellID][time-1][1] + 1)
								DNAcontent = int((4./3)*cellID_time_DSBPhaseTphaseDNAcontentActionPloidyMNparameters[cellID][time-1][3])  #for convenience, e.g., S = 3C and G2 = 4C, thus the content grows by 4/3 times the S
								ploidy = G2M_DNAcontent_ploidy[DNAcontent]
								MN = cellID_time_DSBPhaseTphaseDNAcontentActionPloidyMNparameters[cellID][time-1][6]
	 			
							elif cellID_time_DSBPhaseTphaseDNAcontentActionPloidyMNparameters[cellID][time-1][1] == 2: #if the previous frame was G2
								phase = (cellID_time_DSBPhaseTphaseDNAcontentActionPloidyMNparameters[cellID][time-1][1] + 1)
								DNAcontent = cellID_time_DSBPhaseTphaseDNAcontentActionPloidyMNparameters[cellID][time-1][3]
								ploidy = cellID_time_DSBPhaseTphaseDNAcontentActionPloidyMNparameters[cellID][time-1][5]
								MN = cellID_time_DSBPhaseTphaseDNAcontentActionPloidyMNparameters[cellID][time-1][6]
	 				
							elif cellID_time_DSBPhaseTphaseDNAcontentActionPloidyMNparameters[cellID][time-1][1] == 3: #if the previous frame was M 
								phase = (cellID_time_DSBPhaseTphaseDNAcontentActionPloidyMNparameters[cellID][time-1][1] + 1)
								DNAcontent = int((cellID_time_DSBPhaseTphaseDNAcontentActionPloidyMNparameters[cellID][time-1][3])/2.) #devision will half the DNA content
								ploidy = cellID_time_DSBPhaseTphaseDNAcontentActionPloidyMNparameters[cellID][time-1][5]
								
		
								if ploidy >= 4: #if polyploid
									P_MN_DSB = (DSB)/(DSB+Kd_MN)
									P_MN = P_MN_DSB + P_MN_error - P_MN_DSB*P_MN_error 	#the probability of either P(A) and P(B) happens is P(A) + P(B) - P(A)*P(B)
									if True if random.random() > 1-P_MN else False:
										MN = 1
									else:
										MN = 0
								else:        #if diploid
									P_MN_DSB = (DSB)/(DSB+Kd_MN)
									P_MN = P_MN_DSB   #if diploid, the probability of division resulting in mitotic error will solely depend on the level of DSBs
									if True if random.random() > 1-P_MN else False:
										MN = 1
									else:
										MN = 0
				
								#---generate a daughter cell and put in the pools dictionary---
				
								action = decision(phase,Tphase,DSB,MN)
								num_division += 1
				
								cellIDdaughter = cellID+"_"+str(num_division)
				 
								cellID_poolnum[cellIDdaughter] = next_poolnum
				
								if next_poolnum in pool_list:
									pool_list[next_poolnum][cellIDdaughter] = {"initial_time":time,"DNAcontent":DNAcontent,"ploidy":ploidy,"Tphase":Tphase,"action":action,"MN":MN,"phase":phase}
								else:
									pool_list[next_poolnum] = {cellIDdaughter:{"initial_time":time,"DNAcontent":DNAcontent,"ploidy":ploidy,"Tphase":Tphase,"action":action,"MN":MN,"phase":phase}}
								#---------------------------------------------------------	
	 			
							elif cellID_time_DSBPhaseTphaseDNAcontentActionPloidyMNparameters[cellID][time-1][1] == 0: #if the previous frame was G0 
								phase = (cellID_time_DSBPhaseTphaseDNAcontentActionPloidyMNparameters[cellID][time-1][1] + 1) #current phase is S phase
								DNAcontent = int(1.5*cellID_time_DSBPhaseTphaseDNAcontentActionPloidyMNparameters[cellID][time-1][3]) #for convenience, e.g., G0 = 2C and S = 3C, so the content grows 1.5 times the G0
								ploidy = cellID_time_DSBPhaseTphaseDNAcontentActionPloidyMNparameters[cellID][time-1][5]
								MN = cellID_time_DSBPhaseTphaseDNAcontentActionPloidyMNparameters[cellID][time-1][6]
	 			
							else:
								print("error")
						else:
							pass
	 		
						action = decision(phase,Tphase,DSB,MN)
	 		
	 					#-----write information into the dictionary
						if time in cellID_time_DSBPhaseTphaseDNAcontentActionPloidyMNparameters[cellID]:
							print("error")
						else:
							cellID_time_DSBPhaseTphaseDNAcontentActionPloidyMNparameters[cellID][time] = [DSB,phase,Tphase,DNAcontent,action,ploidy,MN,DSBcondition,k_G1toG0,k_G2toG0,k_G0toS,Kd_G1toG0,Kd_G2toG0,Kd_G0toS]

	 					#-----write information into an output file
						if time >= start_write and time <= end_write:
							fileout.write(str('{:020.0f}'.format(parset))+"\t"+str(rep)+"\t"+str(cellID)+"\t"+str(time)+"\t"+str(DSB)+"\t"+str(phase)+"\t"+str(DNAcontent)+"\t"+str(ploidy)+"\t"+str(MN)+"\t"+str('{:010.4f}'.format(DSBcondition))+"\t"+str('{:010.4f}'.format(k_G1toG0))+"\t"+str('{:010.4f}'.format(k_G2toG0))+"\t"+str('{:010.4f}'.format(k_G0toS))+"\t"+str('{:010.4f}'.format(Kd_G1toG0background))+"\t"+str('{:010.4f}'.format(Kd_G2toG0background))+"\t"+str('{:010.4f}'.format(Kd_G0toSbackground))+"\t"+str('{:010.4f}'.format(G1check_inhibition_perturbed))+"\t"+str('{:010.4f}'.format(G2check_inhibition_perturbed))+"\t"+str('{:010.4f}'.format(check_inhibition_perturbed))+"\n")
						else:
							pass
	
				
			else:
				pass
			

fileout.flush() 
fileout.close()			
	 			
	 		
	 		
			

	
	
	
			
		 

		
